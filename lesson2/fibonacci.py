# # # #用程式算出費布那西數列

# # # # fibonacci01.py

# # # def fibonacci(n):
# # #     if (n ==1) or (n ==2):
# # #         return 1
# # #     return fibonacci(n-2) + fibonacci(n -1)

# # # #這是在函式中呼叫函式自己，這種寫作稱為『遞迴』。這裡的重點是，要呼叫函數時的引數，是比原本的引數小的，換句話說，這個方式是將較大的處裡切割為較小的處裡。
# # # #由於處裡內容相同，因此我們使用相同的函式，但大小會越來越小，最終會完成處裡。
# # # #眾所周知，使用遞迴的話，就能簡單地實做這樣的程式。但是，為了結束處裡，必須指定中止條件（如果沒有結束條件…那麼處裡將會無限繼續下去）。以這裡的情況來說，我們設定的是，當n=1或n=2時處裡就會結束。
# # # #再來看看n=6時的狀況

# # # fibonacci02.py

# # def fibonacci(n):
# #     if (n ==1) or (n ==2):
# #         return 1
# #     return fibonacci(n-2) + fibonacci(n -1)

# # print(fibonacci(6))


# # #此程式中，我們可以看到fibonacci這個函式被呼叫了很多次，如fibonacci(1)以及fibonacci(2)是終止條件，都會回傳1，計算會在這裡停下來，將各自的結果加起來，就能得到費布那西數列的值。
# # #用這個函數可以毫無問題地進行計算，但是如果給定的n變大，那麼處裡時間也會變長。
# # #原因是我們對於同一個質重複計算了很多次
# # #但是每次fibonacci(4)不管執行計次，回傳的質都是一樣的，換句話說，如果第一次就把結果記錄下來，那麼第二次以後就不用執行了



# #用記憶法加速處裡
# # fibonacci03.py
# #為了解決上述問題，先試著將處裡結果記錄下來，並且改寫為程式


# memo = {1: 1, 2: 1} #將終止條件的質放入字典
# def fibonacci(n):
#     if n in memo:
#         return memo[n] #如果字典中有這個值，就回傳該值


#     memo[n] = fibonacci(n-2) + fibonacci(n-1) #如果字典中沒有，就計算並放入字典
#     return memo[n]

# #這種方式稱為『記憶法』memoization或稱為『記憶化』，在解決某些意志問題之類的問題時，常會用到。還有一種不使用遞迴而是使用迴圈的方式。對於費布那西數這種簡單的問題，可以將它們按順序加到串列中，就能輕易計算
# # 
# # 
#  fibonacci4.py    

def fibonacci(n):
    fib=[1, 1]
    for i in range(2, n):
        fib.append(fib[i - 2] + fib[i - 1])

    return fib[ n -1]

#像這樣，各種不同的實作方式都能得到相同結果。如果要評估的話，考慮的不只是處裡速度，還有原始碼的可維護性（易讀性，易修改）等各種不同的標準。批開始可能會煩惱到底哪個才好，我們可以長是以多種方式實作，並從不同角度來比較。
#後續會側重於處裡速度來比較演算法     